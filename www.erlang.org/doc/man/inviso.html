<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- inviso</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../../../doc/js/erlresolvelinks.js"></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small>
<a href="../apps/inviso/users_guide.html">User's Guide</a><br>
<a href="../apps/inviso/index.html">Reference Manual</a><br>
<a href="../apps/inviso/release_notes.html">Release Notes</a><br>
<a href="../apps/inviso/inviso.pdf">PDF</a><br>
<a href="../index.html">Top</a></small><p><strong>Inviso</strong><br><strong>Reference Manual</strong><br><small>Version 0.6.1</small></p>
<br>
<a href="javascript:openAllFlips()">Expand All</a><br>
<a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="inviso " expanded="true">inviso<ul>
<li>
<a href="inviso.html">
                  Top of manual page
                </a></li>
<li title="start-0">
<a href="inviso.html#start-0">start/0</a></li>
<li title="start-1">
<a href="inviso.html#start-1">start/1</a></li>
<li title="stop-0">
<a href="inviso.html#stop-0">stop/0</a></li>
<li title="add_node-1">
<a href="inviso.html#add_node-1">add_node/1</a></li>
<li title="add_node-2">
<a href="inviso.html#add_node-2">add_node/2</a></li>
<li title="add_node_if_ref-1">
<a href="inviso.html#add_node_if_ref-1">add_node_if_ref/1</a></li>
<li title="add_node_if_ref-2">
<a href="inviso.html#add_node_if_ref-2">add_node_if_ref/2</a></li>
<li title="add_nodes-2">
<a href="inviso.html#add_nodes-2">add_nodes/2</a></li>
<li title="add_nodes-3">
<a href="inviso.html#add_nodes-3">add_nodes/3</a></li>
<li title="add_nodes_if_ref-2">
<a href="inviso.html#add_nodes_if_ref-2">add_nodes_if_ref/2</a></li>
<li title="add_nodes_if_ref-3">
<a href="inviso.html#add_nodes_if_ref-3">add_nodes_if_ref/3</a></li>
<li title="stop_nodes-0">
<a href="inviso.html#stop_nodes-0">stop_nodes/0</a></li>
<li title="stop_nodes-1">
<a href="inviso.html#stop_nodes-1">stop_nodes/1</a></li>
<li title="stop_all-0">
<a href="inviso.html#stop_all-0">stop_all/0</a></li>
<li title="change_options-1">
<a href="inviso.html#change_options-1">change_options/1</a></li>
<li title="change_options-2">
<a href="inviso.html#change_options-2">change_options/2</a></li>
<li title="init_tracing-1">
<a href="inviso.html#init_tracing-1">init_tracing/1</a></li>
<li title="init_tracing-1">
<a href="inviso.html#init_tracing-1">init_tracing/1</a></li>
<li title="init_tracing-2">
<a href="inviso.html#init_tracing-2">init_tracing/2</a></li>
<li title="stop_tracing-1">
<a href="inviso.html#stop_tracing-1">stop_tracing/1</a></li>
<li title="stop_tracing-0">
<a href="inviso.html#stop_tracing-0">stop_tracing/0</a></li>
<li title="clear-0">
<a href="inviso.html#clear-0">clear/0</a></li>
<li title="clear-2">
<a href="inviso.html#clear-2">clear/2</a></li>
<li title="clear-1">
<a href="inviso.html#clear-1">clear/1</a></li>
<li title="tp-6">
<a href="inviso.html#tp-6">tp/6</a></li>
<li title="tp-5">
<a href="inviso.html#tp-5">tp/5</a></li>
<li title="tp-5">
<a href="inviso.html#tp-5">tp/5</a></li>
<li title="tp-4">
<a href="inviso.html#tp-4">tp/4</a></li>
<li title="tp-2">
<a href="inviso.html#tp-2">tp/2</a></li>
<li title="tp-1">
<a href="inviso.html#tp-1">tp/1</a></li>
<li title="tpl-5">
<a href="inviso.html#tpl-5">tpl/5</a></li>
<li title="tpl-6">
<a href="inviso.html#tpl-6">tpl/6</a></li>
<li title="tpl-4">
<a href="inviso.html#tpl-4">tpl/4</a></li>
<li title="tpl-5">
<a href="inviso.html#tpl-5">tpl/5</a></li>
<li title="tpl-2">
<a href="inviso.html#tpl-2">tpl/2</a></li>
<li title="tpl-1">
<a href="inviso.html#tpl-1">tpl/1</a></li>
<li title="ctp-4">
<a href="inviso.html#ctp-4">ctp/4</a></li>
<li title="ctp-3">
<a href="inviso.html#ctp-3">ctp/3</a></li>
<li title="ctpl-4">
<a href="inviso.html#ctpl-4">ctpl/4</a></li>
<li title="ctpl-3">
<a href="inviso.html#ctpl-3">ctpl/3</a></li>
<li title="tf-3">
<a href="inviso.html#tf-3">tf/3</a></li>
<li title="tf-2">
<a href="inviso.html#tf-2">tf/2</a></li>
<li title="tf-2">
<a href="inviso.html#tf-2">tf/2</a></li>
<li title="tf-1">
<a href="inviso.html#tf-1">tf/1</a></li>
<li title="tf-1">
<a href="inviso.html#tf-1">tf/1</a></li>
<li title="ctf-3">
<a href="inviso.html#ctf-3">ctf/3</a></li>
<li title="ctf-2">
<a href="inviso.html#ctf-2">ctf/2</a></li>
<li title="ctf-2">
<a href="inviso.html#ctf-2">ctf/2</a></li>
<li title="ctf-1">
<a href="inviso.html#ctf-1">ctf/1</a></li>
<li title="ctf_all-1">
<a href="inviso.html#ctf_all-1">ctf_all/1</a></li>
<li title="ctf_all-0">
<a href="inviso.html#ctf_all-0">ctf_all/0</a></li>
<li title="init_tpm-4">
<a href="inviso.html#init_tpm-4">init_tpm/4</a></li>
<li title="init_tpm-5">
<a href="inviso.html#init_tpm-5">init_tpm/5</a></li>
<li title="init_tpm-7">
<a href="inviso.html#init_tpm-7">init_tpm/7</a></li>
<li title="init_tpm-8">
<a href="inviso.html#init_tpm-8">init_tpm/8</a></li>
<li title="tpm-4">
<a href="inviso.html#tpm-4">tpm/4</a></li>
<li title="tpm-5">
<a href="inviso.html#tpm-5">tpm/5</a></li>
<li title="tpm-5">
<a href="inviso.html#tpm-5">tpm/5</a></li>
<li title="tpm-6">
<a href="inviso.html#tpm-6">tpm/6</a></li>
<li title="tpm-8">
<a href="inviso.html#tpm-8">tpm/8</a></li>
<li title="tpm-9">
<a href="inviso.html#tpm-9">tpm/9</a></li>
<li title="tpm_tracer-4">
<a href="inviso.html#tpm_tracer-4">tpm_tracer/4</a></li>
<li title="tpm_tracer-5">
<a href="inviso.html#tpm_tracer-5">tpm_tracer/5</a></li>
<li title="tpm_tracer-5">
<a href="inviso.html#tpm_tracer-5">tpm_tracer/5</a></li>
<li title="tpm_tracer-6">
<a href="inviso.html#tpm_tracer-6">tpm_tracer/6</a></li>
<li title="tpm_tracer-8">
<a href="inviso.html#tpm_tracer-8">tpm_tracer/8</a></li>
<li title="tpm_tracer-9">
<a href="inviso.html#tpm_tracer-9">tpm_tracer/9</a></li>
<li title="tpm_ms-5">
<a href="inviso.html#tpm_ms-5">tpm_ms/5</a></li>
<li title="tpm_ms-6">
<a href="inviso.html#tpm_ms-6">tpm_ms/6</a></li>
<li title="tpm_ms_tracer-5">
<a href="inviso.html#tpm_ms_tracer-5">tpm_ms_tracer/5</a></li>
<li title="tpm_ms_tracer-6">
<a href="inviso.html#tpm_ms_tracer-6">tpm_ms_tracer/6</a></li>
<li title="ctpm_ms-4">
<a href="inviso.html#ctpm_ms-4">ctpm_ms/4</a></li>
<li title="ctpm_ms-5">
<a href="inviso.html#ctpm_ms-5">ctpm_ms/5</a></li>
<li title="ctpm-3">
<a href="inviso.html#ctpm-3">ctpm/3</a></li>
<li title="ctpm-4">
<a href="inviso.html#ctpm-4">ctpm/4</a></li>
<li title="tpm_localnames-0">
<a href="inviso.html#tpm_localnames-0">tpm_localnames/0</a></li>
<li title="tpm_localnames-1">
<a href="inviso.html#tpm_localnames-1">tpm_localnames/1</a></li>
<li title="ctpm_localnames-0">
<a href="inviso.html#ctpm_localnames-0">ctpm_localnames/0</a></li>
<li title="ctpm_localnames-1">
<a href="inviso.html#ctpm_localnames-1">ctpm_localnames/1</a></li>
<li title="tpm_globalnames-0">
<a href="inviso.html#tpm_globalnames-0">tpm_globalnames/0</a></li>
<li title="tpm_globalnames-1">
<a href="inviso.html#tpm_globalnames-1">tpm_globalnames/1</a></li>
<li title="ctpm_globalnames-0">
<a href="inviso.html#ctpm_globalnames-0">ctpm_globalnames/0</a></li>
<li title="ctpm_globalnames-1">
<a href="inviso.html#ctpm_globalnames-1">ctpm_globalnames/1</a></li>
<li title="ctp_all-0">
<a href="inviso.html#ctp_all-0">ctp_all/0</a></li>
<li title="ctp_all-1">
<a href="inviso.html#ctp_all-1">ctp_all/1</a></li>
<li title="suspend-1">
<a href="inviso.html#suspend-1">suspend/1</a></li>
<li title="suspend-2">
<a href="inviso.html#suspend-2">suspend/2</a></li>
<li title="cancel_suspension-0">
<a href="inviso.html#cancel_suspension-0">cancel_suspension/0</a></li>
<li title="cancel_suspend-1">
<a href="inviso.html#cancel_suspend-1">cancel_suspend/1</a></li>
<li title="get_status-0">
<a href="inviso.html#get_status-0">get_status/0</a></li>
<li title="get_status-1">
<a href="inviso.html#get_status-1">get_status/1</a></li>
<li title="get_tracerdata-0">
<a href="inviso.html#get_tracerdata-0">get_tracerdata/0</a></li>
<li title="get_tracerdata-1">
<a href="inviso.html#get_tracerdata-1">get_tracerdata/1</a></li>
<li title="list_logs-0">
<a href="inviso.html#list_logs-0">list_logs/0</a></li>
<li title="list_logs-1">
<a href="inviso.html#list_logs-1">list_logs/1</a></li>
<li title="list_logs-1">
<a href="inviso.html#list_logs-1">list_logs/1</a></li>
<li title="list_logs-1">
<a href="inviso.html#list_logs-1">list_logs/1</a></li>
<li title="fetch_log-3">
<a href="inviso.html#fetch_log-3">fetch_log/3</a></li>
<li title="fetch_log-2">
<a href="inviso.html#fetch_log-2">fetch_log/2</a></li>
<li title="delete_log-2">
<a href="inviso.html#delete_log-2">delete_log/2</a></li>
<li title="delete_log-1">
<a href="inviso.html#delete_log-1">delete_log/1</a></li>
<li title="delete_log-1">
<a href="inviso.html#delete_log-1">delete_log/1</a></li>
<li title="delete_log-1">
<a href="inviso.html#delete_log-1">delete_log/1</a></li>
<li title="delete_log-0">
<a href="inviso.html#delete_log-0">delete_log/0</a></li>
<li title="subscribe-0">
<a href="inviso.html#subscribe-0">subscribe/0</a></li>
<li title="subscribe-1">
<a href="inviso.html#subscribe-1">subscribe/1</a></li>
<li title="unsubscribe-0">
<a href="inviso.html#unsubscribe-0">unsubscribe/0</a></li>
<li title="unsubscribe-1">
<a href="inviso.html#unsubscribe-1">unsubscribe/1</a></li>
</ul>
</li>
<li title="inviso_as_lib " expanded="false">inviso_as_lib<ul>
<li>
<a href="inviso_as_lib.html">
                  Top of manual page
                </a></li>
<li title="setup_autostart-8">
<a href="inviso_as_lib.html#setup_autostart-8">setup_autostart/8</a></li>
<li title="set_repeat-2">
<a href="inviso_as_lib.html#set_repeat-2">set_repeat/2</a></li>
<li title="inhibit_autostart-1">
<a href="inviso_as_lib.html#inhibit_autostart-1">inhibit_autostart/1</a></li>
</ul>
</li>
<li title="inviso_lfm " expanded="false">inviso_lfm<ul>
<li>
<a href="inviso_lfm.html">
                  Top of manual page
                </a></li>
<li title="merge-2">
<a href="inviso_lfm.html#merge-2">merge/2</a></li>
<li title="merge-3">
<a href="inviso_lfm.html#merge-3">merge/3</a></li>
<li title="merge-5">
<a href="inviso_lfm.html#merge-5">merge/5</a></li>
</ul>
</li>
<li title="inviso_lfm_tpfreader " expanded="false">inviso_lfm_tpfreader<ul>
<li>
<a href="inviso_lfm_tpfreader.html">
                  Top of manual page
                </a></li>
<li title="handle_logfile_sort_wrapset-1">
<a href="inviso_lfm_tpfreader.html#handle_logfile_sort_wrapset-1">handle_logfile_sort_wrapset/1</a></li>
</ul>
</li>
<li title="inviso_rt " expanded="false">inviso_rt<ul>
<li>
<a href="inviso_rt.html">
                  Top of manual page
                </a></li>
<li title="init_tracing-1">
<a href="inviso_rt.html#init_tracing-1">init_tracing/1</a></li>
<li title="tp-5">
<a href="inviso_rt.html#tp-5">tp/5</a></li>
<li title="tp-4">
<a href="inviso_rt.html#tp-4">tp/4</a></li>
<li title="tp-1">
<a href="inviso_rt.html#tp-1">tp/1</a></li>
<li title="tpl-4">
<a href="inviso_rt.html#tpl-4">tpl/4</a></li>
<li title="tpl-5">
<a href="inviso_rt.html#tpl-5">tpl/5</a></li>
<li title="tpl-1">
<a href="inviso_rt.html#tpl-1">tpl/1</a></li>
<li title="ctp-3">
<a href="inviso_rt.html#ctp-3">ctp/3</a></li>
<li title="ctpl-3">
<a href="inviso_rt.html#ctpl-3">ctpl/3</a></li>
<li title="tf-2">
<a href="inviso_rt.html#tf-2">tf/2</a></li>
<li title="tf-1">
<a href="inviso_rt.html#tf-1">tf/1</a></li>
<li title="ctf-2">
<a href="inviso_rt.html#ctf-2">ctf/2</a></li>
<li title="ctf-1">
<a href="inviso_rt.html#ctf-1">ctf/1</a></li>
<li title="init_tpm-4">
<a href="inviso_rt.html#init_tpm-4">init_tpm/4</a></li>
<li title="init_tpm-7">
<a href="inviso_rt.html#init_tpm-7">init_tpm/7</a></li>
<li title="tpm-4">
<a href="inviso_rt.html#tpm-4">tpm/4</a></li>
<li title="tpm-5">
<a href="inviso_rt.html#tpm-5">tpm/5</a></li>
<li title="tpm-8">
<a href="inviso_rt.html#tpm-8">tpm/8</a></li>
<li title="tpm_tracer-4">
<a href="inviso_rt.html#tpm_tracer-4">tpm_tracer/4</a></li>
<li title="tpm_tracer-5">
<a href="inviso_rt.html#tpm_tracer-5">tpm_tracer/5</a></li>
<li title="tpm_tracer-8">
<a href="inviso_rt.html#tpm_tracer-8">tpm_tracer/8</a></li>
<li title="tpm_ms-5">
<a href="inviso_rt.html#tpm_ms-5">tpm_ms/5</a></li>
<li title="tpm_ms_tracer-5">
<a href="inviso_rt.html#tpm_ms_tracer-5">tpm_ms_tracer/5</a></li>
<li title="ctpm_ms-4">
<a href="inviso_rt.html#ctpm_ms-4">ctpm_ms/4</a></li>
<li title="ctpm-3">
<a href="inviso_rt.html#ctpm-3">ctpm/3</a></li>
<li title="local_register-0">
<a href="inviso_rt.html#local_register-0">local_register/0</a></li>
<li title="remove_local_register-0">
<a href="inviso_rt.html#remove_local_register-0">remove_local_register/0</a></li>
<li title="global_register-0">
<a href="inviso_rt.html#global_register-0">global_register/0</a></li>
<li title="remove_global_register-0">
<a href="inviso_rt.html#remove_global_register-0">remove_global_register/0</a></li>
</ul>
</li>
<li title="inviso_rt_meta " expanded="false">inviso_rt_meta<ul>
<li>
<a href="inviso_rt_meta.html">
                  Top of manual page
                </a></li>
<li title="tpm_ms-5">
<a href="inviso_rt_meta.html#tpm_ms-5">tpm_ms/5</a></li>
<li title="tpm_ms_tracer-5">
<a href="inviso_rt_meta.html#tpm_ms_tracer-5">tpm_ms_tracer/5</a></li>
<li title="list_tpm_ms-3">
<a href="inviso_rt_meta.html#list_tpm_ms-3">list_tpm_ms/3</a></li>
<li title="ctpm_ms-4">
<a href="inviso_rt_meta.html#ctpm_ms-4">ctpm_ms/4</a></li>
<li title="get_tracer-0">
<a href="inviso_rt_meta.html#get_tracer-0">get_tracer/0</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>inviso</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">inviso</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Main API Module to the Inviso Tracer</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>With the <span class="code">inviso</span> API runtime components can be started and tracing managed across a network of distributed Erlang nodes, using a control component also started with <span class="code">inviso</span> API functions.</p>
    <p>Inviso can be used both in a distributed environment and in a non-distributed. API functions not taking a list of nodes as argument works on all started runtime components. If it is the non-distributed case, that is the local runtime component. The API functions taking a list of nodes as argument, or as part of one of the arguments, can not be used in a non-distributed environment. Return values named <span class="code">NodeResult</span> refers to return values from a single Erlang node, and will therefore be the return in the non-distributed environment.</p>
  </p></div>
  <h3>EXPORTS</h3>
    <p><a name="start-0"><span class="bold_code">start() -&gt; {ok,pid()} | {error,Reason}</span></a><br><a name="start-1"><span class="bold_code">start(Options) -&gt; {ok,pid()} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Options = [Option]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p><span class="code">Options</span> may contain both options which will be default options to a runtime component when started, and options to the control component. See <span class="bold_code">
<a href="#add_nodes-3">add_nodes/3</a></span> for details on runtime component options. The control component recognizes the following options:</p>
        <dl>
          <dt><strong><span class="code">{subscribe,Pid}</span></strong></dt>
          <dd>
            <p>Making the process <span class="code">Pid</span> receive Inviso events from the control component.</p>
            <p>Starts a control component process on the local node. A control component must be started before runtime components can be started manually or otherwise accessed through the <span class="code">inviso</span> API.</p>
          </dd>
        </dl>
      </p></div>
    <p><a name="stop-0"><span class="bold_code">stop() -&gt; shutdown</span></a><br></p>
<div class="REFBODY"><p>
        <p>Stops the control component. Runtime components are left as is. They will behave according to their dependency values.</p>
      </p></div>
    <p><a name="add_node-1"><span class="bold_code">add_node(RTtag) -&gt; NodeResult | {error,Reason}</span></a><br><a name="add_node-2"><span class="bold_code">add_node(RTtag,Options) -&gt; NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">RTtag = PreviousRTtag = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options = [Option]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Option -- see below</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Option = {dependency,Dep}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Dep = int() | infinity</span><br>
</div>
        <div class="REFBODY">The timeout, in milliseconds, before the runtime component will terminate if abandoned by <strong>this</strong>control component.</div>
        <div class="REFTYPES">
<span class="bold_code"> Option = {overload,Overload} | overload</span><br>
</div>
        <div class="REFBODY">Controls how and how often overload checks shall be performed. Just <span class="code">overload</span>specifies that no loadcheck shall be performed.</div>
        <div class="REFTYPES">
<span class="bold_code">  Overload = Interval | {LoadMF,Interval,InitMFA,RemoveMFA}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">   LoadMF = {Mod,Func} | function()/1</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">   Interval = int() | infinity</span><br>
</div>
        <div class="REFBODY">Interval is the time in milliseconds between overload checks.</div>
        <div class="REFTYPES">
<span class="bold_code">   InitMFA = RemoveMFA = {Mod,Func,ArgList} | void</span><br>
</div>
        <div class="REFBODY">When starting up the runtime component or when changing options (see <span class="code">change_options/2</span>) the overload mechanism is initialized with a call to the <span class="code">InitMFA</span>function. It shall return <span class="code">LoadCheckData</span>. Every time a load check is performed, <span class="code">LoadMF</span>is called with <span class="code">LoadCheckData</span>as its only argument. <span class="code">LoadMF</span>shall return <span class="code">ok</span>or <span class="code">{suspend,Reason}</span>. When the runtime component is stopped or made to change options involving changing overload-check, the <span class="code">RemoveMFA</span>function is called. Its return value is discarded.</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,NAns} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> NAns = new | {adopted,State,Status,PreviousRTtag} | already_added</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  State = new | tracing | idle</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Status = running | {suspended,SReason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts or tries to connect to an existing runtime component at the local node, regardless if the system is distributed or not. <span class="code">Options</span> will override any default options specified at start-up of the control component.</p>
        <p>The <span class="code">PreviousRTtag</span> can indicate if the incarnation of the runtime component at the node in question was started by "us" and then can be expected to do tracing according to "our" instructions or not.</p>
      </p></div>
    <p><a name="add_node_if_ref-1"><span class="bold_code">add_node_if_ref(RTtag) -&gt; NodeResult | {error,{wrong_reference,OtherTag}} | {error,Reason}</span></a><br><a name="add_node_if_ref-2"><span class="bold_code">add_node_if_ref(RTtag,Options) -&gt; NodeResult | {error,{wrong_reference,OtherRef}} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">OtherRef = term()</span><br>
</div>
        <div class="REFBODY">rttag of the running incarnation</div>
      </div>
<div class="REFBODY"><p>
        <p>As <span class="bold_code">
<a href="#add_node-1">add_node/1,2</a></span> but will only adopt the runtime component if its rttag is <span class="code">RTtag</span>.</p>
      </p></div>
    <p><a name="add_nodes-2"><span class="bold_code">add_nodes(Nodes,RTtag) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="add_nodes-3"><span class="bold_code">add_nodes(Nodes,RTtag,Options) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>As <span class="bold_code">
<a href="#add_node-1">add_node/1,2</a></span> but for a distributed environment.</p>
      </p></div>
    <p><a name="add_nodes_if_ref-2"><span class="bold_code">add_nodes_if_ref(Nodes,RTtag) -&gt; NodeResult | {error,Reason}</span></a><br><a name="add_nodes_if_ref-3"><span class="bold_code">add_nodes_if_ref(Nodes,RTtag,Options) -&gt; NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>As <span class="bold_code">
<a href="#add_node_if_ref-1">add_node_if_ref/1,2</a></span> but for a distributed environment.</p>
      </p></div>
    <p><a name="stop_nodes-0"><span class="bold_code">stop_nodes() -&gt; {ok,NodeResults} | NodeResult</span></a><br><a name="stop_nodes-1"><span class="bold_code">stop_nodes(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Stops runtime component on <span class="code">Nodes</span>. <span class="code">stop_nodes/0</span> will if the control component is running on a distributed node stop all runtime components. And if running on a non distributed node, stop the local and only runtime component.</p>
      </p></div>
    <p><a name="stop_all-0"><span class="bold_code">stop_all() = {ok,NodeResults} | NodeResult</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>A combination of <span class="bold_code">
<a href="#stop-0">stop/0</a></span> and <span class="bold_code">
<a href="#stop_nodes-0">stop_nodes/0</a></span>.</p>
      </p></div>
    <p><a name="change_options-1"><span class="bold_code">change_options(Options) -&gt; NodeResult | {ok,NodeResults} | {error,Reason}</span></a><br><a name="change_options-2"><span class="bold_code">change_options(Nodes,Options) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Changes the options for one or several runtime components. If for instance overload is redefined, the previous overload will be stopped and the new started. See <span class="bold_code">
<a href="#add_node-1">add_node/1</a></span> for details on <span class="code">Options</span>.</p>
      </p></div>
    <p><a name="init_tracing-1"><span class="bold_code">init_tracing(TracerData) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="init_tracing-1"><span class="bold_code">init_tracing(TracerList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="init_tracing-2"><span class="bold_code">init_tracing(Nodes,TracerData) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">TracerData = [{trace,LogTD} [,{ti,TiTD}] }] | LogTD</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">LogTD = {HandlerFun,Data1} | collector | {relayer,CollectingNode} | {ip,IPPortParameters} | {file,FilePortParameters}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TiTD = {file,FileName} | {file,FileName,TiSpec} | {relay,Node}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> TiSpec = {InitMFA,RemoveMF,CleanMF}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  InitMFA = {Mi,Fi,Argsi}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  RemoveMF = {Mr,Fr} | void</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  CleanMF = {Mc,Fc}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Mi = Fi = Mr = Fr = Mc = Fd = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Argsi = [term()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TracerList = [{Node,TracerData}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">IPPortParameters = Portno | {Portno,Qsize}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Portno = tcp_portno()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Qsize = int()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FilePortParameters =  {Filename,wrap,Tail,{time,WrapTime},WrapCnt} | {FileName,wrap,Tail,WrapSize,WrapCnt} | {FileName,wrap,Tail,WrapSize} | {FileName,wrap,Tail} | FileName</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> FileName = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Tail = string() =/= ""</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> WrapTime = WrapCnt = WrapSize = int() &gt;0</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TracerList = [{Node,TracerData}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">HandlerFun = function()/2;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> HandlerFun(TraceMsg,Data1) -&gt; NewData</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CollectingNode = pid() | node()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,LogResults} | {error,NReason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> LogResults = [LogResult]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  LogResult = {trace_log,LogRes} | {ti_log,LogRes}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">   LogRes = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts the tracing at the specified nodes, meaning that the runtime components transits from the state <span class="code">new</span> or <span class="code">idle</span> to <span class="code">tracing</span>. For trace messages to be generated, there must of course also be trace pattern and/or trace flags set. Such can not be set before tracing has been initiated with <span class="code">init_tracing/1,2</span>.</p>
        <p><span class="code">TracerData</span> controls how the runtime component will handle generated trace messages. The <span class="code">trace</span> tag controls how regular trace messages are handled. The <span class="code">ti</span> tag controls if and how trace information will be stored and the meta tracer will be activated. That is if <span class="code">ti</span> is omitted, no meta tracer will be started as part of the runtime component. It is possible to have <span class="code">ti</span> without <span class="code">trace</span>, but most likely not useful.</p>
        <p>The <span class="code">ip</span> and <span class="code">file</span> trace tracerdata instructions results in using the built in trace ip-port and file-port respectively.  <span class="code">relayer</span> will result in that all regular trace messages are forwarded to a runtime component at the specified node. Using a <span class="code">HandlerFun</span> will result in that every incoming regular trace message is applied to the <span class="code">HandlerFun</span>. <span class="code">collector</span> can be used to use this runtime component to receive relayed trace messages and print them to the shell.
          </p>
        <p>The trace information can be configured to either write trace information to a plain trace information file or to relay it to another inviso meta tracer on another node. The inviso meta tracer is capable of matching function calls with their function returns (only if <span class="code">return_trace</span> is activated in the meta trace match specification for the function in question). This is necessary since it may not be possible to decide what to do, if anything shall be done at all, until the return value of the function call is examined.
          </p>
        <p>To be able to match calls with returns a state can be saved when detecting a function call in a public loop data structure kept by the inviso meta tracer. The public loop data structure is given as argument to a handler-function called whenever a meta trace message arrives to the inviso meta tracer (both function calls and function returns). The public loop data structure is first initiated by the <span class="code">Mi:Fi</span> function which takes the items in <span class="code">Argsi</span> as arguments. <span class="code">Fi</span> shall return the initial public loop data structure. When meta tracing is stopped, either because tracing is stopped or because tracing is suspended, the <span class="code">Mr:Fr(PublicLoopData)</span> is called to offer a possibility to clean-up. Note that for every function meta-tracing is activated, a public loop data modification function can be specified. That function will prepare the current loop data structure for this particular function.
          </p>
        <p>Further there is a risk that function call states becomes abandoned inside the public loop data structure. This will happen if a function call is entered into the public loop data structure, but no function return occurs. To prevent the public loop data structure from growing infinitely the clean function <span class="code">Fc</span> will periodically be called with the public loop data structure as argument. Elements entered into the public loop data structure as a result of a function call must contain a timestamp for the <span class="code">Fc</span> to be able to conclude if it is abandoned or not. <span class="code">Fc</span> shall return a new public loop data structure.
          </p>
        <p>When initiating tracing involving trace information without a <span class="code">TiSpec</span>, a default public loop data structure will be initiated to handle locally registered process aliases. The default public loop data structure is a two-tuple where the first element is used by the meta tracing on the BIF <span class="code">register/2</span>. The second element is left for user usage.</p>
        <p>The default public loop data structure may be extended with more element positions. The first position must be left to the implementation of registered-name translations. If the public loop data structure is changed no longer meeting this requirement, the <span class="bold_code">
<a href="#tpm_localnames-0">tpm_localnames/0,1</a></span> and <span class="bold_code">
<a href="#tpm_globalnames-0">tpm_globalnames/0,1</a></span> can no longer be used.</p>
        <p>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are <span class="code">Filename ++ SeqCnt ++ Tail</span>, where <span class="code">SeqCnt</span> counts as a decimal string from 0 to <span class="code">WrapCnt</span> and then around again from 0. When a trace message written to the current file makes it longer than <span class="code">WrapSize</span>, that file is closed, if the number of files in this wrap trace is as many as <span class="code">WrapCnt</span> the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most <span class="code">WrapCnt</span> trace files saved with a size of at least <span class="code">WrapSize</span> (but not much bigger), except for the last file that might even be empty. The default values are <span class="code">WrapSize == 128*1024</span> and <span class="code">WrapCnt == 8</span>.</p>
        <p>The <span class="code">SeqCnt</span> values in the filenames are all in the range 0 through <span class="code">WrapCnt</span> with a gap in the circular sequence. The gap is needed to find the end of the trace.</p>
        <p>If the <span class="code">WrapSize</span> is specified as <span class="code">{time,WrapTime}</span>, the current file is closed when it has been open more than <span class="code">WrapTime</span> milliseconds, regardless of it being empty or not.</p>
        <p>The ip trace driver has a queue of <span class="code">QSize</span> messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced by the runtime system, they are dropped. The number of dropped messages are indicated in the trace log as separate trace message.</p>
      </p></div>
    <p><a name="stop_tracing-1"><span class="bold_code">stop_tracing(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="stop_tracing-0"><span class="bold_code">stop_tracing() -&gt; {ok,NodeResults} | NodeResult</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,State} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> State = new | idle</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Stops tracing on all or specified <span class="code">Nodes</span>. Flushes the trace buffer if a trace-port is used, closes the trace-port and removes all trace flags and meta-patterns. The nodes are called in parallel.</p>
        <p>Stopping tracing means going to state <span class="code">idle&lt;c&gt;. If the runtime component was already in state &lt;c&gt;new</span>, it will of course remain in state <span class="code">new</span> (then there was no tracing to stop).</p>
      </p></div>
    <p><a name="clear-0"><span class="bold_code">clear() -&gt; {ok,NodeResults} | NodeResult</span></a><br><a name="clear-2"><span class="bold_code">clear(Nodes,Options) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="clear-1"><span class="bold_code">clear(Options) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options = [Option]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Option = keep_trace_patterns | keep_log_files</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> NodeResult = {ok,{new,Status}} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Status = running | {suspended,SReason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Stops all tracing including removing meta-trace patterns. Removes all trace patterns. If the node is <span class="code">tracing</span> or <span class="code">idle</span>, trace-logs belonging to the current tracerdata are removed. Hence the node is returned to state <span class="code">new</span>. Note that the node can still be suspended.</p>
        <p>Various options can make the node keep set trace patterns and log-files. The node still enters the <span class="code">new</span> state.</p>
      </p></div>
    <p><a name="tp-6"><span class="bold_code">tp(Nodes,Mod,Func,Arity,MatchSpec,Opts) -&gt; </span></a><br><a name="tp-5"><span class="bold_code">tp(Nodes,Mod,Func,Arity,MatchSpec) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tp-5"><span class="bold_code">tp(Mod,Func,Arity,MatchSpec,Opts) -&gt; </span></a><br><a name="tp-4"><span class="bold_code">tp(Mod,Func,Arity,MatchSpec) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tp-2"><span class="bold_code">tp(Nodes,PatternList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tp-1"><span class="bold_code">tp(PatternList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Mod = Func = atom() | '_'</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Arity = int() | '_'</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MatchSpec = true | false | [] | matchspec()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PatternList = [Pattern],</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Pattern = {Mod,Func,Arity,MatchSpec,Opts}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opts = [Opt]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Opt = only_loaded</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [NodeResult]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> NodeResult = {ok,[Ans]} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Ans = int() | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Set trace pattern (global) on specified or all nodes. The integer replied if the call was successfully describes the number of matched functions. The functions without a <span class="code">Nodes</span> argument means all nodes, in a non-distributed environment it means the local node. Using wildcards follows the rules for wildcards of <span class="code">erlang:trace_pattern/3</span>. It is for instance illegal to specify <span class="code">M == '_'</span> while <span class="code">F</span> is not <span class="code">'_'</span>.</p>
        <p>When calling several nodes, the nodes are called in parallel.</p>
        <p>The option <span class="code">only_loaded</span> will prevent modules not loaded (yet) into the runtime system to become loaded just as a result of that a trace pattern is requested to be set on it. Otherwise modules are automatically loaded if not already loaded (since the module must be present for a trace pattern to be set on it). The latter does not apply if the wildcard <span class="code">'_'</span> is used as module specification.</p>
      </p></div>
    <p><a name="tpl-5"><span class="bold_code">tpl(Nodes,Mod,Func,Arity,MatchSpec) -&gt; </span></a><br><a name="tpl-6"><span class="bold_code">tpl(Nodes,Mod,Func,Arity,MatchSpec,Opts) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpl-4"><span class="bold_code">tpl(Mod,Func,Arity,MatchSpec) -&gt; </span></a><br><a name="tpl-5"><span class="bold_code">tpl(Mod,Func,Arity,MatchSpec,Opts) -&gt; {ok,NodeResults} | NodeResult| {error,Reason}</span></a><br><a name="tpl-2"><span class="bold_code">tpl(Nodes,PatternList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpl-1"><span class="bold_code">tpl(PatternList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See <span class="bold_code">
<a href="#tp-6">tp/N</a></span> function above for details on arguments and return values.</p>
        <p>Set local trace pattern on specified functions. When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="ctp-4"><span class="bold_code">ctp(Nodes,Mod,Func,Arity) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="ctp-3"><span class="bold_code">ctp(Mod,Func,Arity) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See <span class="bold_code">
<a href="#tp-6">tp/N</a></span> for argument descriptions.</p>
        <p>Clear global trace patterns. When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="ctpl-4"><span class="bold_code">ctpl(Nodes,Mod,Func,Arity) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="ctpl-3"><span class="bold_code">ctpl(Mod,Funct,Arity) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See <span class="bold_code">
<a href="#tp-6">tp/N</a></span> for argument description.</p>
        <p>Clear local trace patterns. When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="tf-3"><span class="bold_code">tf(Nodes,PidSpec,FlagList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tf-2"><span class="bold_code">tf(PidSpec,FlagList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tf-2"><span class="bold_code">tf(Nodes,TraceConfList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tf-1"><span class="bold_code">tf(NodeTraceConfList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tf-1"><span class="bold_code">tf(TraceConfList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeTraceConfList = [{Node,TraceConfList}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TraceConfList = [{PidSpec,FlagList}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FlagList = [Flag]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PidSpec = all | new| existing | pid() | locally_registered_name()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Flag -- see erlang:trace/3</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,[Ans]} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Ans = int() | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Set process trace flags on processes on all or specified nodes. The integer returned if the call was successful describes the matched number of processes. The functions without a <span class="code">Nodes</span> argument means all nodes, in a non-distributed environment it means the local node.
          </p>
        <p>There are many combinations which does not make much sense. For instance specifying a certain process identifier at all nodes. Or an empty <span class="code">TraceConfList</span> for all nodes.</p>
        <p>When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="ctf-3"><span class="bold_code">ctf(Nodes,PidSpec,FlagList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="ctf-2"><span class="bold_code">ctf(PidSpec,FlagList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctf-2"><span class="bold_code">ctf(Nodes,TraceConfList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="ctf-1"><span class="bold_code">ctf(TraceConfList) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See <span class="bold_code">
<a href="#tf-3">tf/N</a></span> for arguments and return value description.</p>
        <p>Clear process trace flags on all or specified nodes. When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="ctf_all-1"><span class="bold_code">ctf_all(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="ctf_all-0"><span class="bold_code">ctf_all() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Clears all trace flags on all or specified nodes. Just for convenience.</p>
      </p></div>
    <p><a name="init_tpm-4"><span class="bold_code">init_tpm(Mod,Func,Arity,CallFunc) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="init_tpm-5"><span class="bold_code">init_tpm(Nodes,Mod,Func,Arity,CallFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="init_tpm-7"><span class="bold_code">init_tpm(Mod,Func,Arity,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="init_tpm-8"><span class="bold_code">init_tpm(Nodes,Mod,Func,Arity, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Mod = Func = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Arity = int()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">InitFunc,RemoveFunc = {Module,Function} | function()/4 | void</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CallFunc = ReturnFunc = {Module,Function} | function()/3 | void</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes <span class="code">Mod:Func/Arity</span> for meta tracing without setting any meta trace patterns. This is necessary if the named match specs will be used (see <span class="bold_code">
<a href="#tpm_ms-5">tpm_ms/5,6</a></span>). Otherwise initialization of public loop data can be done at the same time as setting meta trace patterns using <span class="bold_code">
<a href="#tpm-8">tpm/8,9</a></span>.</p>
        <p>Note that we can not use wildcards here (even if it is perfectly legal in Erlang). It also sets the <span class="code">CallFunc</span> and <span class="code">ReturnFunc</span> for the meta traced function. That is the functions which will be called when a function call and a return_trace meta trace message respectively arrives to the inviso meta tracer for <span class="code">Mod:Func/Arity</span>.</p>
        <p>This function is also available without <span class="code">InitFunc</span> and <span class="code">RemoveFunc</span>. That means that no initialization of the public loop data structure will be done and that <span class="code">CallFunc</span> and <span class="code">ReturnFunc</span> must either use already existing parts of public loop data structure or not use it at all.</p>
        <p>The <span class="code">InitFunc</span> initializes the already existing public loop data structure for use with <span class="code">Mod:Func/Arity. InitFunc(Mod,Func,Arity,PublLD) -&gt; {ok,NewPublLD,Output}</span> where <span class="code">OutPut</span> can be a binary which will then be written to the trace information file. If it is not a binary, no output will be done. <span class="code">RemoveFunc</span> will be called when the meta tracing is cleared with <span class="bold_code">
<a href="#ctpm-3">ctpm/3,4</a></span>. <span class="code">RemoveFunc(Mod,Func,Arity,PublLD) -&gt; {ok,NewPublLD}</span>.</p>
        <p>See <span class="bold_code">
<a href="#tpm-4">tpm/N</a></span> for details on <span class="code">CallFunc</span> and <span class="code">ReturnFunc</span>.</p>
      </p></div>
    <p><a name="tpm-4"><span class="bold_code">tpm(Mod,Func,Arity,MS) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm-5"><span class="bold_code">tpm(Nodes,Mod,Func,Arity,MS) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpm-5"><span class="bold_code">tpm(Mod,Func,Arity,MS,CallFunc) -&gt; {ok,NodeResults} | NodeResults | {error,Reason}</span></a><br><a name="tpm-6"><span class="bold_code">tpm(Nodes,Mod,Func,Arity,MS,CallFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpm-8"><span class="bold_code">tpm(Mod,Func,Arity,MS,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | NodeResults | {error,Reason}</span></a><br><a name="tpm-9"><span class="bold_code">tpm(Nodes,Mod,Func,Arity,MS, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Mod = Func = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Arity = int()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MS = [match_spec()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">InitFunc = RemoveFunc = {Module,Function} | function()/4 | void</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CallFunc = ReturnFunc = {Module,Function} | function()/3 | void</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,1} | {ok,0} | {error,Reason}1</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Activates meta-tracing in the inviso_rt_meta tracer. Except when using <span class="code">tpm/6</span>, <span class="code">tpm/8</span> and <span class="code">tpm/9</span> the <span class="code">Mod:Func/Arity</span> must first have been initiated using <span class="bold_code">
<a href="#init_tpm-4">init_tpm/N</a></span>. When calling several nodes, the nodes are called in parallel.</p>
        <p><span class="code">CallFunc</span> will be called every time a meta trace message arrives to the inviso meta tracer because of a call to <span class="code">Func</span>. <span class="code">CallFunc(CallingPid,ActualArgList,PublLD) -&gt; {ok,NewPrivLD,Output}</span> where <span class="code">Output</span> can be a binary or <span class="code">void</span>. If it is a binary it will be written to the trace information file.</p>
        <p><span class="code">ReturnFunc</span> will be called every time a meta return_trace message arrives to the inviso meta tracer because of a return_trace of a call to <span class="code">Func</span>. <span class="code">ReturnFunc(CallingPid,ReturnValue,PublLD) -&gt; {ok,NewPrivLD,Output}</span>. Further the <span class="code">ReturnFunc</span> must handle the fact that a return_trace message arrives for a call which was never noticed. This because the message queue of the meta tracer may have been emptied.</p>
      </p></div>
    <p><a name="tpm_tracer-4"><span class="bold_code">tpm_tracer(Mod,Func,Arity,MS) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm_tracer-5"><span class="bold_code">tpm_tracer(Nodes,Mod,Func,Arity,MS) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpm_tracer-5"><span class="bold_code">tpm_tracer(Mod,Func,Arity,MS,CallFunc) -&gt; {ok,NodeResults} | NodeResults | {error,Reason}</span></a><br><a name="tpm_tracer-6"><span class="bold_code">tpm_tracer(Nodes,Mod,Func,Arity,MS,CallFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="tpm_tracer-8"><span class="bold_code">tpm_tracer(Mod,Func,Arity,MS,InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | NodeResults | {error,Reason}</span></a><br><a name="tpm_tracer-9"><span class="bold_code">tpm_tracer(Nodes,Mod,Func,Arity,MS, InitFunc,CallFunc,ReturnFunc,RemoveFunc) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See tpm/X for details on arguments and return values.</p>
        <p>Same as tpm/X but all match specs in <span class="code">MS</span> containing a <span class="code">trace</span> action term will have a <span class="code">{tracer,Tracer}</span> appended to its enable-list. <span class="code">Tracer</span> will be the current output for regular trace messages as specified when tracing was initiated. This function is useful when setting a meta trace pattern on a function with the intent that its execution shall turn tracing on for the process executing the match-spec in the meta trace pattern. The reason the <span class="code">tracer</span> process trace flag can not be explicitly written in the action term by the user is that it may be difficult to learn its exact value for a remote node. Further more inviso functions are made to work on several nodes at the same time, requiring different match specs to be set for different nodes.</p>
        <p>Simple example: We want any process executing the function <span class="code">mymod:init(1234)</span> (with the argument, exactly the integer 1234) to begin function-call tracing. In the example, if the process is found to be one that shall start call tracing, we also first disable <span class="code">all</span> process trace flags to ensure that we have full control over what the process traces. <span class="code">void</span> in the example specifies that the meta-tracer (inviso_rt_meta) will not call any function when meta trace messages for <span class="code">mymod:init/1</span> arrives. There is no need for a <span class="code">CallFunc</span> since the side-effect (start call-tracing) is achieved immediately with the match-spec.</p>
        <div class="example"><pre>
    inviso:tpm_tracer(mymod,init,1,[{[1234],[],[{trace,[all],[call]}]}],void).        </pre></div>
        <p>This will internally, by the meta tracer on each Erlang node, be translated to:</p>
        <div class="example"><pre>
    erlang:trace_pattern({mymod,init,1},[{[1234],[],[{trace,[all],[call,{{tracer,T}}]}]}],[{meta,P}]).
        </pre></div>
        <p>Where <span class="code">T</span> is the tracer for regular trace messages (most often a trace-port, but can be the runtime component inviso_rt process), and <span class="code">P</span> is the meta tracer (the inviso_rt_meta process).</p>
      </p></div>
    <p><a name="tpm_ms-5"><span class="bold_code">tpm_ms(Mod,Func,Arity,MSname,MS) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm_ms-6"><span class="bold_code">tpm_ms(Nodes,Mod,Func,Arity,MSname,MS) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]&lt;v&gt; &lt;v&gt;Mod = Func = atom()&lt;v&gt; &lt;v&gt;Arity = int()&lt;v&gt; &lt;v&gt;MSname = term()&lt;v&gt; &lt;v&gt;MS = [match_spec()]&lt;v&gt; &lt;v&gt;NodeResults = [{Node,NodeResult}]&lt;v&gt; &lt;v&gt;NodeResult = {ok,1} | {ok,0} | {error,Reason}&lt;v&gt;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function adds a list of match-specs to the already existing ones. It uses an internal database to keep track of existing match-specs. This set of match specs can hereafter be referred to with the name <span class="code">MSname</span>. If the match-spec does not result in any meta traced functions (for whatever reason), the <span class="code">MS</span> is not saved in the database. The previously known match-specs are not removed. If <span class="code">MSname</span> is already in use as a name referring to a set of match-specs for this particular meta-traced function, the previous set of match-specs are replaced with <span class="code">MS</span>.</p>
        <p><span class="code">Mod:Func/Arity</span> must previously have been initiated in order for this function to add a match-spec.</p>
        <p>When calling several nodes, the nodes are called in parallel. <span class="code">{ok,1}</span> indicates success.</p>
      </p></div>
    <p><a name="tpm_ms_tracer-5"><span class="bold_code">tpm_ms_tracer(Mod,Func,Arity,MSname,MS) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm_ms_tracer-6"><span class="bold_code">tpm_ms_tracer(Nodes,Mod,Func,Arity,MSname,MS) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>See tpm_ms/X for details on arguments and return values, and tpm_tracer/X for explanations about the appending of <span class="code">{tracer,Tracer}</span> process trace flag.</p>
      </p></div>
    <p><a name="ctpm_ms-4"><span class="bold_code">ctpm_ms(Mod,Func,Arity,MSname) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctpm_ms-5"><span class="bold_code">ctpm_ms(Nodes,Mod,Func,Arity,MSname) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Removes a named match-spec from the meta traced function. Note that it never is a fault to remove a match spec. Not even from a function which is non existent.</p>
        <p>When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="ctpm-3"><span class="bold_code">ctpm(Mod,Func,Arity) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctpm-4"><span class="bold_code">ctpm(Nodes,Mod,Func,Arity) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Removes the meta trace pattern for the function, means stops generating output for this function. The public loop data structure may be cleared by the previously entered <span class="code">RemoveFunc</span>.</p>
        <p>When calling several nodes, the nodes are called in parallel.</p>
      </p></div>
    <p><a name="tpm_localnames-0"><span class="bold_code">tpm_localnames() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm_localnames-1"><span class="bold_code">tpm_localnames(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {R1,R2}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">R1 = R2 = {ok,0} | {ok,1} | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Quick version for setting meta-trace patterns on <span class="code">erlang:register/2</span>. It uses a default <span class="code">CallFunc</span> and <span class="code">ReturnFunc</span> in the meta-tracer server. The main purpose of this function is to create ti-log entries for associations between pids and registered name aliases. The implementation uses return_trace to see if the registration was successful or not, before actually making the ti-log alias entry. Further the implementation also meta traces the BIF <span class="code">unregister/1</span>.</p>
        <p>If both <span class="code">N1</span> and <span class="code">N2</span> is 1, function call was successful. <span class="code">N1</span> and <span class="code">N2</span> represent setting meta trace pattern on <span class="code">register/2</span> and <span class="code">unregister/1</span>.</p>
      </p></div>
    <p><a name="ctpm_localnames-0"><span class="bold_code">ctpm_localnames() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctpm_localnames-1"><span class="bold_code">ctpm_localnames(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {R1,R2}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">R1 = R2 = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Function for removing previously set patters by <span class="bold_code">
<a href="#tpm_localnames-0">tpm_localnames/0</a></span>. The two results <span class="code">R1</span> and <span class="code">R2</span> represents that meta pattern is removed from both <span class="code">register/2</span> and <span class="code">unregister/1</span>.</p>
      </p></div>
    <p><a name="tpm_globalnames-0"><span class="bold_code">tpm_globalnames() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="tpm_globalnames-1"><span class="bold_code">tpm_globalnames(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {R1,R2}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">R1 = R2 = {ok,0} | {ok,1} | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Quick version for setting meta-trace patterns capable of learning the association of a pid with a globally registered name (registered using <span class="code">global:register_name</span>). The implementation meta-traces on <span class="code">global:handle_call({register,'_','_','_'},'_','_')</span> and <span class="code">global:delete_global_name/2</span>. The <span class="code">N1</span> and <span class="code">N2</span> represents the success of the two sub-tmp calls.</p>
      </p></div>
    <p><a name="ctpm_globalnames-0"><span class="bold_code">ctpm_globalnames() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctpm_globalnames-1"><span class="bold_code">ctpm_globalnames(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {R1,R2} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">R1 = R2 = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Function for removing previously set meta patters by <span class="bold_code">
<a href="#tpm_globalnames-0">tpm_globalnames/0,1</a></span>. The two results <span class="code">R1</span> and <span class="code">R2</span> represents that meta pattern are removed from both <span class="code">global:handle_call/3</span> and <span class="code">global:delete_global_name/1</span>.</p>
      </p></div>
    <p><a name="ctp_all-0"><span class="bold_code">ctp_all() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="ctp_all-1"><span class="bold_code">ctp_all(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Clears all, both global and local trace patterns. Does not clear meta trace patterns. Equivalent to a call to <span class="bold_code">
<a href="#ctp-4">ctp/3,4</a></span> and to <span class="bold_code">
<a href="#ctpl-4">ctpl/3,4</a></span> with wildcards <span class="code">'_'</span> for all modules, functions and arities.</p>
      </p></div>
    <p><a name="suspend-1"><span class="bold_code">suspend(SReason) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="suspend-2"><span class="bold_code">suspend(Nodes,SReason) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">SReason = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Suspends the runtime components. <span class="code">SReason</span> will become the suspend-reason replied in for instance a <span class="bold_code">
<a href="#get_status-0">get_status/0,1</a></span> call. A runtime component that becomes suspended removes all trace flags and all meta trace patterns. In that way trace output is no longer generated. The task of reactivating a suspended runtime component is outside the scoop of inviso. It can for instance be implemented by a higher layer trace-tool "remembering" all trace flags and meta patterns set.</p>
      </p></div>
    <p><a name="cancel_suspension-0"><span class="bold_code">cancel_suspension() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="cancel_suspend-1"><span class="bold_code">cancel_suspend(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = ok | {error,Reason}</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Makes the runtime components <span class="code">running</span> again (as opposite to <span class="code">suspended).</span> Since reactivating previous trace flags and meta trace patterns is outside the scoop of inviso, cancelling suspension is simply making it possible to set trace flags and meta trace patterns again.</p>
      </p></div>
    <p><a name="get_status-0"><span class="bold_code">get_status() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="get_status-1"><span class="bold_code">get_status(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,{State,Status}} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">State = new | idle | tracing</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Status = running | {suspended,SReason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SReason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Finds out the state and status of a runtime component. A runtime component is in state <span class="code">new</span> before it has been initiated to do any tracing the first time. There are clear-functions which can make a runtime component become <span class="code">new</span> again without having to restart. A runtime component becomes <span class="code">idle</span> after tracing is stopped.</p>
      </p></div>
    <p><a name="get_tracerdata-0"><span class="bold_code">get_tracerdata() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="get_tracerdata-1"><span class="bold_code">get_tracerdata(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,NResult} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NResult = TracerData | no_tracerdata</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the current tracerdata of a runtime component. A runtime component in state <span class="code">new</span> can not have tracerdata. An <span class="code">idle</span> runtime component does have tracerdata, the last active tracerdata. <span class="code">TracerData</span> will be a term as specified to <span class="code">init_tracing</span> when tracing was initiated for the runtime component.</p>
      </p></div>
    <p><a name="list_logs-0"><span class="bold_code">list_logs() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="list_logs-1"><span class="bold_code">list_logs(Nodes) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="list_logs-1"><span class="bold_code">list_logs(NodeTracerData) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="list_logs-1"><span class="bold_code">list_logs(TracerData) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">TracerData -- see init_tracing/1,2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,FileList} | {ok,no_log} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> FileList = [FileType]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  FileType = {trace_log,Dir,Files} | {ti_log,Dir,Files}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  Files = [FileNameWithOutPath]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the actually existing log files associated with <span class="code">TracerData</span>. If a tracerdata is not specified, current tracerdata is used for that particular runtime component. <span class="code">Files</span> will be a list of one or more files should it be a wrap-set. Otherwise the it is a list of only one filename.</p>
        <p>This function is useful to learn the name and path of all files belonging to a trace. This information can later be used to move those files for merging. Note that since it is possible to ask on other tracerdata than the current, it is possible to learn filenames of previously done traces, under the circumstances that they have not been removed.</p>
      </p></div>
    <p><a name="fetch_log-3"><span class="bold_code">fetch_log(LogSpecList,DestDir,Prefix) -&gt; {ok,NodeResults} | {error,not_distributed} | {error,Reason} </span></a><br><a name="fetch_log-2"><span class="bold_code">fetch_log(DestDir,Prefix) -&gt; {ok,NodeResults} | {error,not_distributed} | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">DestDir = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Prefix = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">LogSpecList = [LogSpec]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> LogSpec = {Node,FileSpecList} | Node | {Node,TracerData}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TracerData = see init_tracing/1,/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FileSpecList = [{trace_log,Dir,FileList},{ti_log,Dir,FileList}] | [{trace_log,Dir,FileList}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> FileList = [RemoteFileName]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {Conclusion,ResultFileSpec} | no_log | {error,NReason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> NReason = own_node | Reason</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Conclusion = complete | incomplete</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> ResultFileSpec = [{trace_log,FileResults},{ti_log,FileResults}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  FileResults = [FileResult]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">     FileResult = {ok,FileName} | {error,FReason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">    FReason = {file_open,{posix(),FileName}} | {file_open,{posix(),RemoteFileName}} | {file_open,{posix(),[DestDir,Prefix,RemoteFileName]}} | {file_write,{posix(),FileName}} | {truncated,FileName} | {truncated,{Reason,FileName}}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">     posix() = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Copies log files over distributed erlang to the control component node. This function can only be used in a distributed system.</p>
        <p>The resulting transferred files will have the prefix <span class="code">Prefix</span> and will be located in <span class="code">DestDir</span>. The source files can either be pointed out using a <span class="code">FileListSpec</span> or tracerdata. If no files are explicitly specified, current tracerdata for that node will be used. Note that if source files have the same name (on several nodes) they will overwrite each other at <span class="code">DestDir</span>.</p>
      </p></div>
    <p><a name="delete_log-2"><span class="bold_code">delete_log(Nodes,TracerData) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="delete_log-1"><span class="bold_code">delete_log(NodeSpecList) -&gt; {ok,NodeResults} | {error,Reason}</span></a><br><a name="delete_log-1"><span class="bold_code">delete_log(Spec) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="delete_log-1"><span class="bold_code">delete_log(TracerData) -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br><a name="delete_log-0"><span class="bold_code">delete_log() -&gt; {ok,NodeResults} | NodeResult | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Nodes = [Node]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeSpecList = [{Node,Spec}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> Spec = [AbsPathFileName] | LogSpecs</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  LogSpecs = [LogSpec]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">   LogSpec = {trace_log,Dir,[FileNameWithoutPath]} | {ti_log,Dir,[FileNameWithoutPath]}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TracerData -- see init_tracing/1,/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResults = [{Node,NodeResult}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NodeResult = {ok,no_log} | {ok,LogInfos} | {ok,FileInfos}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> LogInfos = [LogInfo]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  LogInfo = {trace_log,FileInfos} | {ti_log,FileInfos}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code"> FileInfos = [FileInfo]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">  FileInfo = {ok,FileName} | {error,Reason} </span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Deletes listed files or files corresponding to tracerdata. If no tracerdata or list of files are specified in the call, current tracerdata at the runtime components will be used to identify files to delete. All filenames shall be strings.</p>
        <p><span class="code">FileName</span> can either be an absolute path or just a filename depending on if <span class="code">AbsPathFileName</span> or a <span class="code">LogSpec</span> was used to identify the file.</p>
      </p></div>
    <p><a name="subscribe-0"><span class="bold_code">subscribe() -&gt; ok | {error,Reason}</span></a><br><a name="subscribe-1"><span class="bold_code">subscribe(Pid) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Pid = pid()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Adds <span class="code">Pid</span> or <span class="code">self()</span> if using <span class="code">subscribe/0</span> to the inviso-event sending list. Note that it is possible to add a pid several times and that the <span class="code">Pid</span> then will receive multiple copies of inviso-event messages.</p>
        <p>All events will be sent to all subscribers in the event sending list.</p>
        <div class="example"><pre>
Event = {inviso_event,ControllerPid,erlang:localtime(),Msg}
  Msg = {connected, Node, {RTtag, {State,Status}}}
      | {disconnected, Node, NA}
      | {state_change,Node,{State,Status}}
      | {port_down,Node,Reason}
    Node = node() | local_runtime
        </pre></div>
        <p>Subscribing to inviso-event may be necessary for a higher layer trace-tool using inviso to follow the runtime components. <span class="code">local_runtime</span> will be used for a runtime component running in a non-distributed environment.</p>
      </p></div>
    <p><a name="unsubscribe-0"><span class="bold_code">unsubscribe() -&gt; ok</span></a><br><a name="unsubscribe-1"><span class="bold_code">unsubscribe(Pid) -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
        <p>Removes <span class="code">Pid</span> (once) from the subscription list.</p>
      </p></div>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2006-2009 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3045895-1";
urchinTracker();
</script> 
</body>
</html>
